/* Shared Use License: This file is owned by Derivative Inc. (Derivative)
* and can only be used, and/or modified for use, in conjunction with
* Derivative's TouchDesigner software, and only if you are a licensee who has
* accepted Derivative's TouchDesigner license or assignment agreement
* (which also govern the use of this file). You may share or redistribute
* a modified version of this file provided the following conditions are met:
*
* 1. The shared file or redistribution must retain the information set out
* above and this list of conditions.
* 2. Derivative's name (Derivative Inc.) or its trademarks may not be used
* to endorse or promote products derived from this file without specific
* prior written permission from Derivative.
*/


#include "TouchInputGetK2Node.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"

#include "KismetCompiler.h"
#include "K2Node_CallFunction.h"

#include "TouchBlueprintFunctionLibrary.h"
#include "TouchEngineComponent.h"


struct FTEInputGet_GetPinNames
{
	static const FName& GetPinNameVarName()
	{
		static const FName TextPinName(TEXT("InputName"));
		return TextPinName;
	}
	static const FName& GetPinNameComponent()
	{
		static const FName TextPinName(TEXT("TouchEngineComponent"));
		return TextPinName;
	}
	static const FName& GetPinNameOutputValue()
	{
		static const FName TextPinName(TEXT("Value"));
		return TextPinName;
	}

	static const FName& GetPinNameOutput()
	{
		static const FName OutputPinName(TEXT("Result"));
		return OutputPinName;
	}
};


void UTouchInputGetK2Node::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	// Create out pins

	// Execution Pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	// Variable Pins

	// Input
	UEdGraphPin* InTextPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, FTEInputGet_GetPinNames::GetPinNameVarName());
	K2Schema->SetPinAutogeneratedDefaultValue(InTextPin, FString(""));
	UEdGraphPin* InObjectPin = CreatePin(EGPD_Input, FName(TEXT("Object")), UTouchEngineComponentBase::StaticClass(), FTEInputGet_GetPinNames::GetPinNameComponent());
	// Output
	UEdGraphPin* OutValuePin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, FTEInputGet_GetPinNames::GetPinNameOutputValue());
	UEdGraphPin* OutValidPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, FTEInputGet_GetPinNames::GetPinNameOutput());
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(OutValidPin);
}

FText UTouchInputGetK2Node::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return FText::FromString("Get TouchEngine Input Latest Value");
}

FText UTouchInputGetK2Node::GetTooltipText() const
{
	return FText::FromString("Get TouchEngine Input Latest Value");
}

FText UTouchInputGetK2Node::GetMenuCategory() const
{
	return FText::FromString("TouchEngine");
}

void UTouchInputGetK2Node::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	if (!FindPin(FTEInputGet_GetPinNames::GetPinNameComponent())->HasAnyConnections())
	{
		CompilerContext.MessageLog.Error(*(FString("No Target Component connected")), this);
	}

	// Check input pin type to make sure it's a supported type for touchengine
	UEdGraphPin* valuePin = FindPin(FTEInputGet_GetPinNames::GetPinNameOutputValue());

	if (!CheckPinCategory(valuePin))
	{
		// pin type is not valid
		valuePin->BreakAllPinLinks();
		return;
	}

	// get the proper function from the library based on pin category
	UFunction* BlueprintFunction = UTouchBlueprintFunctionLibrary::FindInputGetterByType(
		valuePin->PinType.PinCategory,
		valuePin->PinType.ContainerType == EPinContainerType::Array,
		valuePin->PinType.PinSubCategoryObject.IsValid() ? valuePin->PinType.PinSubCategoryObject->GetFName() : FName("")
	);

	if (BlueprintFunction == NULL)
	{
		CompilerContext.MessageLog.Error(*FString("The function has not been found."), this);
		return;
	}

	UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	CallFunction->SetFromFunction(BlueprintFunction);
	CallFunction->AllocateDefaultPins();
	CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);


	//Input
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FTEInputGet_GetPinNames::GetPinNameVarName()), *CallFunction->FindPin(TEXT("VarName")));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FTEInputGet_GetPinNames::GetPinNameComponent()), *CallFunction->FindPin(TEXT("Target")));

	//Output
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FTEInputGet_GetPinNames::GetPinNameOutputValue()), *CallFunction->FindPin(TEXT("value")));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FTEInputGet_GetPinNames::GetPinNameOutput()), *CallFunction->GetReturnValuePin());

	//Exec pins
	UEdGraphPin* NodeExec = GetExecPin();
	UEdGraphPin* NodeThen = FindPin(UEdGraphSchema_K2::PN_Then);

	UEdGraphPin* InternalExec = CallFunction->GetExecPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeExec, *InternalExec);

	UEdGraphPin* InternalThen = CallFunction->GetThenPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeThen, *InternalThen);

	//After we are done we break all links to this node (not the internally created one)
	BreakAllNodeLinks();
}

void UTouchInputGetK2Node::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);

	UClass* Action = GetClass();

	if (ActionRegistrar.IsOpenForRegistration(Action)) {
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		check(Spawner != nullptr);

		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}

void UTouchInputGetK2Node::ReallocatePinsDuringReconstruction(TArray<UEdGraphPin*>& OldPins)
{
	Super::ReallocatePinsDuringReconstruction(OldPins);

	// This is necessary to retain type information after pasting or loading from disc
	if (UEdGraphPin* InputPin = FindPin(FTEInputGet_GetPinNames::GetPinNameOutputValue()))
	{
		// Only update the output pin if it is currently a wildcard
		if (InputPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
		{
			// Find the matching Old Pin if it exists
			for (UEdGraphPin* OldPin : OldPins)
			{
				if (OldPin->PinName == InputPin->PinName)
				{
					// Update our output pin with the old type information and then propagate it to our input pins
					InputPin->PinType = OldPin->PinType;

					auto Schema = GetSchema();
					Schema->RecombinePin(InputPin);

					break;
				}
			}
		}
	}
}

void UTouchInputGetK2Node::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	if (Pin->PinName == FTEInputGet_GetPinNames::GetPinNameOutputValue())
	{
		if (Pin->HasAnyConnections())
		{
			// Check input pin type to make sure it's a supported type for touchengine
			if (!CheckPinCategory(Pin->LinkedTo[0]))
			{
				// pin type is not valid
				Pin->BreakAllPinLinks();
				return;
			}

			Pin->PinType = Pin->LinkedTo[0]->PinType;
		}
		else
		{
			Pin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			Pin->PinType.ContainerType = EPinContainerType::None;
		}
	}
}

bool UTouchInputGetK2Node::CheckPinCategory(UEdGraphPin* Pin)
{
	FName PinCategory = Pin->PinType.PinCategory;

	if (PinCategory == TEXT("float"))
	{
		return true;
	}
	else if (PinCategory == TEXT("int"))
	{
		return true;
	}
	else if (PinCategory == TEXT("int64"))
	{
		return true;
	}
	else if (PinCategory == TEXT("bool"))
	{
		return true;
	}
	else if (PinCategory == TEXT("name"))
	{
		return true;
	}
	else if (PinCategory == TEXT("object"))
	{
		if (Cast<UClass>(Pin->PinType.PinSubCategoryObject.Get())->IsChildOf<UTexture>() || UTexture::StaticClass()->IsChildOf(Cast<UClass>(Pin->PinType.PinSubCategoryObject.Get())))
		{
			return true;
		}

		return false;
	}
	else if (PinCategory == TEXT("class"))
	{
		return false;
	}
	else if (PinCategory == TEXT("byte"))
	{
		return true;
	}
	else if (PinCategory == TEXT("string"))
	{
		return true;
	}
	else if (PinCategory == TEXT("text"))
	{
		return true;
	}
	else if (PinCategory == TEXT("struct"))
	{
		if (Pin->PinType.PinSubCategoryObject.Get()->GetFName() == "Vector")
		{
			return true;
		}
		if (Pin->PinType.PinSubCategoryObject.Get()->GetFName() == "Vector4")
		{
			return true;
		}
		if (Pin->PinType.PinSubCategoryObject.Get()->GetFName() == "Color")
		{
			return true;
		}
	}
	else if (PinCategory == TEXT("enum"))
	{
		return true;
	}

	return false;
}
