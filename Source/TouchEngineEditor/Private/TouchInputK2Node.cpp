// Fill out your copyright notice in the Description page of Project Settings.


#include "TouchInputK2Node.h"

#include "TouchBlueprintFunctionLibrary.h"

#include "KismetCompiler.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"
#include "TouchEngineComponent.h"

#define LOCTEXT_NAMESPACE "UTouchInputK2Node"


struct FGetPinNames
{
	static const FName& GetTextPinVarName()
	{
		static const FName TextPinName(TEXT("InputName"));
		return TextPinName;
	}
	static const FName& GetTextPinDynVarStruct()
	{
		static const FName TextPinName(TEXT("TouchEngineComponent"));
		return TextPinName;
	}
	static const FName& GetTextPinValue()
	{
		static const FName TextPinName(TEXT("Value"));
		return TextPinName;
	}

	static const FName& GetOutputPin() 
	{
		static const FName OutputPinName(TEXT("Result"));
		return OutputPinName;
	}
};





FText UTouchInputK2Node::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("TouchSetInput_K2Node", "Set Touch Engine Input");
}

void UTouchInputK2Node::AllocateDefaultPins() 
{
	Super::AllocateDefaultPins();
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	/*Create our pins*/

	// Execution pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	// Variable pins

	//Input
	UEdGraphPin* InTextPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, FGetPinNames::GetTextPinVarName());
	K2Schema->SetPinAutogeneratedDefaultValue(InTextPin, FString(""));
	UEdGraphPin* InObjectPin = CreatePin(EGPD_Input, FName(TEXT("Object")), UTouchEngineComponentBase::StaticClass(), FGetPinNames::GetTextPinDynVarStruct());
	K2Schema->SetPinAutogeneratedDefaultValue(InObjectPin, FString("Touch Engine Component"));
	UEdGraphPin* InValuePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, FGetPinNames::GetTextPinValue());
	K2Schema->SetPinAutogeneratedDefaultValue(InValuePin, FString("Value"));

	//Output
	UEdGraphPin* OutValidPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, FGetPinNames::GetOutputPin());
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(OutValidPin);
}

FText UTouchInputK2Node::GetTooltipText() const
{
	return LOCTEXT("TouchSetInput_K2Node", "Set Touch Engine Input");
}

FText UTouchInputK2Node::GetMenuCategory() const
{
	return LOCTEXT("TouchEnigne_MenuCategory", "TouchEngine");
}

void UTouchInputK2Node::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	//This is just a hard reference to the static method that lives in the BlueprintLibrary. Probably not the best of ways.
	UFunction* BlueprintFunction = UTouchBlueprintFunctionLibrary::StaticClass()->FindFunctionByName(FName(TEXT("TextContainsWhiteSpace")));

	if (BlueprintFunction == NULL) {
		CompilerContext.MessageLog.Error(*LOCTEXT("InvalidFunctionName", "The function has not been found.").ToString(), this);
		return;
	}

	UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

	CallFunction->SetFromFunction(BlueprintFunction);
	CallFunction->AllocateDefaultPins();
	CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);

	//Input
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinNames::GetTextPinVarName()), *CallFunction->FindPin(TEXT("InText")));
	//CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinNames:::GetTextPinDynVarStruct()), *CallFunction->FindPin(TEXT("InText")));
	//CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinNames::GetTextPinValue()), *CallFunction->FindPin(TEXT("InText")));

	//Output
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinNames::GetOutputPin()), *CallFunction->GetReturnValuePin());

	//Exec pins
	UEdGraphPin* NodeExec = GetExecPin();
	UEdGraphPin* NodeThen = FindPin(UEdGraphSchema_K2::PN_Then);

	UEdGraphPin* InternalExec = CallFunction->GetExecPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeExec, *InternalExec);

	UEdGraphPin* InternalThen = CallFunction->GetThenPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeThen, *InternalThen);

	//After we are done we break all links to this node (not the internally created one)
	BreakAllNodeLinks();
}

void UTouchInputK2Node::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);

	UClass* Action = GetClass();

	if (ActionRegistrar.IsOpenForRegistration(Action)) {
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		check(Spawner != nullptr);

		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}

#undef LOCTEXT_NAMESPACE