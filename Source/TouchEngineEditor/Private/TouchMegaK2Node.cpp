// Copyright Â© Derivative Inc. 2021

#include "TouchMegaK2Node.h"

#include "Blueprint/TouchBlueprintFunctionLibrary.h"
#include "Blueprint/TouchEngineComponent.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"
#include "KismetCompiler.h"
#include "ScopedTransaction.h"
#include "ToolMenus.h"
#include "Engine/Texture2D.h"
#include "Kismet2/BlueprintEditorUtils.h"

#define LOCTEXT_NAMESPACE "TouchMegaK2Node"

void UTouchMegaK2Node::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	/*Create our pins*/

	// Execution pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	// Variable pins

	//Input
	UEdGraphPin* InObjectPin = CreateTouchComponentPin(LOCTEXT("Inputs_ObjectTooltip", "TouchEngine Component"));

	for (int i = 0; i < NumInputs; i++)
	{
		UEdGraphPin* InTextPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, NewPinName(FPinNames::InputName, i + 1));
		K2Schema->SetPinAutogeneratedDefaultValue(InTextPin, FString(""));
		UEdGraphPin* InValuePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, NewPinName(FPinNames::Value, i + 1));
		PinPairs.Add(FPinPairs(InTextPin, InValuePin));
	}

	//Output
	//UEdGraphPin* OutValidPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, FPinNames::GetPinNameOutput());
	//K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(OutValidPin);

	for (int i = 0; i < NumOutputs; i++)
	{
		UEdGraphPin* InTextPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, NewPinName(FPinNames::OutputName, i + 1));
		K2Schema->SetPinAutogeneratedDefaultValue(InTextPin, FString(""));
		UEdGraphPin* OutValuePin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, NewPinName(FPinNames::OutputValue, i + 1));
		PinPairs.Add(FPinPairs(InTextPin, OutValuePin));
	}

	// Add input pins to pin pairs
}

FText UTouchMegaK2Node::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("SetGetTEInputsOutputs", "Set / Get TouchEngine Inputs / Outputs");
}

void UTouchMegaK2Node::GetNodeContextMenuActions(UToolMenu* Menu, UGraphNodeContextMenuContext* Context) const
{
	Super::GetNodeContextMenuActions(Menu, Context);

	if (!Context->bIsDebugging)
	{
		FToolMenuSection& Section = Menu->AddSection("UTouchMegaK2Node", LOCTEXT("MakeArrayHeader", "MakeArray"));

		if (Context->Pin != nullptr)
		{
			if (Context->Pin->PinName == FPinNames::TouchEngineComponent || Context->Pin->PinType.PinCategory == "Exec" /*|| Context->Pin->PinName == FTEMega_GetPinNames::GetPinNameOutput()*/)
			{
				return;
			}

			if (Context->Pin->Direction == EGPD_Input && Context->Pin->ParentPin == nullptr)
			{
				Section.AddMenuEntry(
					"RemovePin",
					LOCTEXT("RemovePin", "Remove array element pin"),
					LOCTEXT("RemovePinTooltip", "Remove this array element pin"),
					FSlateIcon(),
					FUIAction(
						FExecuteAction::CreateUObject(const_cast<UTouchMegaK2Node*>(this), &UTouchMegaK2Node::RemovePairedPin, const_cast<UEdGraphPin*>(Context->Pin))
					)
				);
			}
			else if (Context->Pin->Direction == EGPD_Output && Context->Pin->ParentPin == nullptr)
			{
				Section.AddMenuEntry(
					"RemovePin",
					LOCTEXT("RemovePin", "Remove array element pin"),
					LOCTEXT("RemovePinTooltip", "Remove this array element pin"),
					FSlateIcon(),
					FUIAction(
						FExecuteAction::CreateUObject(const_cast<UTouchMegaK2Node*>(this), &UTouchMegaK2Node::RemovePairedPin, const_cast<UEdGraphPin*>(Context->Pin))
					)
				);
			}
		}
	}
}

void UTouchMegaK2Node::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	const UEdGraphSchema* Schema = GetSchema();

	UEdGraphPin* PinComponent = FindPin(FPinNames::TouchEngineComponent);

	if (!PinComponent->HasAnyConnections())
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("NoTargetComponent", "No Target Component connected").ToString(), this);
	}

	UEdGraphPin* PrevThen = nullptr;

	for (int i = 0; i < NumInputs; i++)
	{
		UEdGraphPin* ValuePin = FindPin(NewPinName(FPinNames::Value, i + 1));

		// Check input pin type to make sure it's a supported type for touchengine
		if (!CheckPinCategoryWithDirection(ValuePin, true))
		{
			// pin type is not valid
			ValuePin->BreakAllPinLinks();
			CompilerContext.MessageLog.Error(*LOCTEXT("InvalidPinType", "Invalid pin type found.").ToString(), this);
			return;
		}

		// get the proper function from the library based on pin category
		UFunction* BlueprintFunction = UTouchBlueprintFunctionLibrary::FindSetterByType(
			GetCategoryNameChecked(ValuePin),
			ValuePin->PinType.ContainerType == EPinContainerType::Array,
			ValuePin->PinType.PinSubCategoryObject.IsValid() ? ValuePin->PinType.PinSubCategoryObject->GetFName() : FName("")
		);

		if (BlueprintFunction == NULL) {
			CompilerContext.MessageLog.Error(*LOCTEXT("InvalidFunctionName", "The function has not been found.").ToString(), this);
			return;
		}

		UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

		CallFunction->SetFromFunction(BlueprintFunction);
		CallFunction->AllocateDefaultPins();
		CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);


		//Input
		CompilerContext.MovePinLinksToIntermediate(*FindPin(NewPinName(FPinNames::InputName, i + 1)), *CallFunction->FindPin(TEXT("VarName")));
		Schema->TryCreateConnection(PinComponent->LinkedTo[0], CallFunction->FindPin(TEXT("Target")));
		CompilerContext.MovePinLinksToIntermediate(*ValuePin, *CallFunction->FindPin(TEXT("value")));

		if (PrevThen == nullptr)
		{
			// First node in the chain - move the pin link from the parent node to the first function call
			UEdGraphPin* NodeExec = GetExecPin();
			UEdGraphPin* InternalExec = CallFunction->GetExecPin();

			if (!NodeExec)
				break;;

			CompilerContext.MovePinLinksToIntermediate(*NodeExec, *InternalExec);

			// save the then pin on this node to bind to the next function
			PrevThen = CallFunction->GetThenPin();
		}
		else
		{
			// not the first node in the chain, bind it to the previous function
			UEdGraphPin* InternalExec = CallFunction->GetExecPin();

			bool success = Schema->TryCreateConnection(InternalExec, PrevThen);

			if (!success)
			{
				CompilerContext.MessageLog.Error(*LOCTEXT("FunctionConnectionError", "Connecting functions failed.").ToString(), this);
				return;
			}

			PrevThen = CallFunction->GetThenPin();
		}
	}

	for (int i = 0; i < NumOutputs; i++)
	{
		UEdGraphPin* ValuePin = FindPin(NewPinName(FPinNames::OutputValue, i + 1));

		// Check input pin type to make sure it's a supported type for touchengine
		if (!CheckPinCategoryWithDirection(ValuePin, false))
		{
			// pin type is not valid
			ValuePin->BreakAllPinLinks();
			return;
		}

		UFunction* BlueprintFunction = UTouchBlueprintFunctionLibrary::FindGetterByType(
			GetCategoryNameChecked(ValuePin),
			ValuePin->PinType.ContainerType == EPinContainerType::Array,
			ValuePin->PinType.PinSubCategoryObject.IsValid() ? ValuePin->PinType.PinSubCategoryObject->GetFName() : FName("")
		);

		if (BlueprintFunction == NULL) {
			CompilerContext.MessageLog.Error(*LOCTEXT("InvalidFunctionName", "The function has not been found.").ToString(), this);
			return;
		}

		UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

		CallFunction->SetFromFunction(BlueprintFunction);
		CallFunction->AllocateDefaultPins();
		CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);

		//Input
		CompilerContext.MovePinLinksToIntermediate(*FindPin(NewPinName(FPinNames::OutputName, i + 1)), *CallFunction->FindPin(TEXT("VarName")));
		Schema->TryCreateConnection(FindPin(FPinNames::TouchEngineComponent)->LinkedTo[0], CallFunction->FindPin(TEXT("Target")));

		//Output
		CompilerContext.MovePinLinksToIntermediate(*ValuePin, *CallFunction->FindPin(TEXT("value")));

		if (PrevThen == nullptr)
		{
			// First node in the chain - move the pin link from the parent node to the first function call
			UEdGraphPin* NodeExec = GetExecPin();
			UEdGraphPin* InternalExec = CallFunction->GetExecPin();

			if (!NodeExec)
				break;;

			CompilerContext.MovePinLinksToIntermediate(*NodeExec, *InternalExec);

			// save the then pin on this node to bind to the next function
			PrevThen = CallFunction->GetThenPin();
		}
		else
		{
			// not the first node in the chain, bind it to the previous function
			UEdGraphPin* InternalExec = CallFunction->GetExecPin();

			bool success = Schema->TryCreateConnection(InternalExec, PrevThen);

			if (!success)
			{
				CompilerContext.MessageLog.Error(*LOCTEXT("FunctionConnectionError", "Connecting functions failed.").ToString(), this);
				return;
			}

			PrevThen = CallFunction->GetThenPin();
		}
	}

	// move the last function then pin to the output of the parent node
	UEdGraphPin* NodeThen = FindPin(UEdGraphSchema_K2::PN_Then);
	CompilerContext.MovePinLinksToIntermediate(*NodeThen, *PrevThen);


	//After we are done we break all links to this node (not the internally created one)
	BreakAllNodeLinks();
}

void UTouchMegaK2Node::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);

	UClass* Action = GetClass();

	if (ActionRegistrar.IsOpenForRegistration(Action)) {
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		check(Spawner != nullptr);

		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}

void UTouchMegaK2Node::ReallocatePinsDuringReconstruction(TArray<UEdGraphPin*>& OldPins)
{
	Super::ReallocatePinsDuringReconstruction(OldPins);

	// This is necessary to retain type information after pasting or loading from disc
	for (int i = 0; i < NumInputs; i++)
	{
		if (UEdGraphPin* InputPin = FindPin(NewPinName(FPinNames::Value, i + 1)))
		{
			// Only update the output pin if it is currently a wildcard
			if (InputPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
			{
				// Find the matching Old Pin if it exists
				for (UEdGraphPin* OldPin : OldPins)
				{
					if (OldPin->PinName == InputPin->PinName)
					{
						// Update our output pin with the old type information and then propagate it to our input pins
						InputPin->PinType = OldPin->PinType;

						const UEdGraphSchema* Schema = GetSchema();
						Schema->RecombinePin(InputPin);

						break;
					}
				}
			}
		}
	}

	for (int i = 0; i < NumOutputs; i++)
	{
		if (UEdGraphPin* OutputPin = FindPin(NewPinName(FPinNames::OutputValue, i + 1)))
		{
			// Only update the output pin if it is currently a wildcard
			if (OutputPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
			{
				// Find the matching Old Pin if it exists
				for (UEdGraphPin* OldPin : OldPins)
				{
					if (OldPin->PinName == OutputPin->PinName)
					{
						// Update our output pin with the old type information
						OutputPin->PinType = OldPin->PinType;

						const UEdGraphSchema* Schema = GetSchema();
						Schema->RecombinePin(OutputPin);

						break;
					}
				}
			}
		}
	}
}

void UTouchMegaK2Node::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	if (IsInputValuePin(Pin) || IsOutputValuePin(Pin))
	{
		if (Pin->HasAnyConnections())
		{
			// Check input pin type to make sure it's a supported type for touchengine
			if (!CheckPinCategoryWithDirection(Pin->LinkedTo[0], false))
			{
				// pin type is not valid
				Pin->BreakAllPinLinks();
				return;
			}

			Pin->PinType = Pin->LinkedTo[0]->PinType;
		}
		else
		{
			Pin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			Pin->PinType.ContainerType = EPinContainerType::None;
		}
	}
}

void UTouchMegaK2Node::AddInputPin()
{
	Modify();

	/*
	++NumInputs;
	const FEdGraphPinType& OutputPinType = GetOutputPin()->PinType;
	UEdGraphPin* Pin = CreatePin(EGPD_Input, OutputPinType.PinCategory, OutputPinType.PinSubCategory, OutputPinType.PinSubCategoryObject.Get(), GetPinName(NumInputs - 1));
	GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(Pin);

	const bool bIsCompiling = GetBlueprint()->bBeingCompiled;
	if (!bIsCompiling)
	{
		FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
	}
	*/

	++NumInputs;

	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	FCreatePinParams PinParams;
	PinParams.Index = (NumInputs * 2) + 1;

	UEdGraphPin* InTextPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, NewPinName(FPinNames::InputName, NumInputs), PinParams);
	K2Schema->SetPinAutogeneratedDefaultValue(InTextPin, FString(""));
	PinParams.Index++;
	UEdGraphPin* InValuePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, NewPinName(FPinNames::Value, NumInputs), PinParams);

	PinPairs.Add(FPinPairs(InTextPin, InValuePin));

	const bool bIsCompiling = GetBlueprint()->bBeingCompiled;
	if (!bIsCompiling)
	{
		FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
	}
}

void UTouchMegaK2Node::AddOutputPin()
{
	Modify();

	++NumOutputs;

	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	UEdGraphPin* InTextPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, NewPinName(FPinNames::OutputName, NumOutputs));
	K2Schema->SetPinAutogeneratedDefaultValue(InTextPin, FString(""));
	UEdGraphPin* OutValuePin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, NewPinName(FPinNames::OutputValue, NumOutputs));

	PinPairs.Add(FPinPairs(InTextPin, OutValuePin));

	const bool bIsCompiling = GetBlueprint()->bBeingCompiled;
	if (!bIsCompiling)
	{
		FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
	}
}

void UTouchMegaK2Node::RemovePairedPin(UEdGraphPin* Pin)
{
	check(Pin->ParentPin == nullptr);
	checkSlow(Pins.Contains(Pin));

	FScopedTransaction Transaction(LOCTEXT("RemovePinTx", "RemovePin"));
	Modify();

	/*
	TFunction<void(UEdGraphPin*)> RemovePinLambda = [this, &RemovePinLambda](UEdGraphPin* PinToRemove)
	{
		for (int32 SubPinIndex = PinToRemove->SubPins.Num() - 1; SubPinIndex >= 0; --SubPinIndex)
		{
			RemovePinLambda(PinToRemove->SubPins[SubPinIndex]);
		}

		int32 PinRemovalIndex = INDEX_NONE;
		if (Pins.Find(PinToRemove, PinRemovalIndex))
		{
			Pins.RemoveAt(PinRemovalIndex);
			// PinToRemove->MarkPendingKill(); // TODO. We should not have a MarkPendingKill
			PinToRemove = nullptr;
		}
	};
	*/

	UEdGraphPin* PinFriend = nullptr;
	FPinPairs PairToRemove;

	for (auto&& Pair : PinPairs)
	{
		if (Pin == Pair.NamePin)
		{
			PinFriend = Pair.ValuePin;
			PairToRemove = Pair;
		}
		else if (Pin == Pair.ValuePin)
		{
			PinFriend = Pair.NamePin;
			PairToRemove = Pair;
		}
	}
	if (PairToRemove.NamePin)
	{
		PinPairs.Remove(PairToRemove);
	}

	ensure(PinFriend);

	RemovePin(Pin);
	RemovePin(PinFriend);

	PinConnectionListChanged(Pin);
	PinConnectionListChanged(PinFriend);

	if (IsInputValuePin(Pin) || IsInputNamePin(Pin))
	{
		--NumInputs;
	}
	else
	{
		--NumOutputs;
	}

	SyncPinNames();

	FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
}

bool UTouchMegaK2Node::CheckPinCategoryWithDirection(UEdGraphPin* Pin, bool IsInput)
{
	const FName PinCategory = Pin->PinType.PinCategory;

	if (IsInput)
	{
		CheckPinCategory(Pin);
	}
	else
	{
		if (PinCategory == UEdGraphSchema_K2::PC_Float ||
			PinCategory == UEdGraphSchema_K2::PC_Double ||
			PinCategory == UEdGraphSchema_K2::PC_String)
		{
			return true;
		}
		if (PinCategory == UEdGraphSchema_K2::PC_Object)
		{
			const UClass* ObjectClass = Cast<UClass>(Pin->PinType.PinSubCategoryObject.Get());

			if (ObjectClass == UTexture2D::StaticClass() || ObjectClass->IsChildOf<UTexture2D>() || UTexture2D::StaticClass()->IsChildOf(ObjectClass))
			{
				return true;
			}
			if (ObjectClass == UTouchEngineCHOP::StaticClass() || ObjectClass->IsChildOf<UTouchEngineCHOP>() || UTouchEngineCHOP::StaticClass()->IsChildOf(ObjectClass))
			{
				return true;
			}
			if (ObjectClass == UTouchEngineDAT::StaticClass() || ObjectClass->IsChildOf<UTouchEngineDAT>() || UTouchEngineDAT::StaticClass()->IsChildOf(ObjectClass))
			{
				return true;
			}
		}
	}
	return false;
}

FName UTouchMegaK2Node::NewPinName(FName PinName, int Num)
{
	FString NewString = PinName.ToString() + FString::FromInt(Num);;

	return *NewString;
}

void UTouchMegaK2Node::SyncPinNames()
{
	int32 CurrentNumParentPins = 0;
	int32 CurrentNumOutputParentPins = 0;
	for (int32 PinIndex = 0; PinIndex < Pins.Num(); ++PinIndex)
	{
		UEdGraphPin*& CurrentPin = Pins[PinIndex];
		if (CurrentPin->PinType.PinCategory == "exec" || CurrentPin->PinName == FPinNames::TouchEngineComponent)
		{
			continue;
		}

		if (CurrentPin->Direction == EGPD_Input &&
			CurrentPin->ParentPin == nullptr)
		{
			const FName OldName = CurrentPin->PinName;
			const FName ElementName = GetPinName((CurrentNumParentPins++) + 2);

			CurrentPin->Modify();
			CurrentPin->PinName = ElementName;

			if (CurrentPin->SubPins.Num() > 0)
			{
				const FString OldNameStr = OldName.ToString();
				const FString ElementNameStr = ElementName.ToString();
				FString OldFriendlyName = OldNameStr;
				FString ElementFriendlyName = ElementNameStr;

				// SubPin Friendly Name has an extra space in it so we need to account for that
				OldFriendlyName.InsertAt(1, " ");
				ElementFriendlyName.InsertAt(1, " ");

				for (UEdGraphPin* SubPin : CurrentPin->SubPins)
				{
					FString SubPinFriendlyName = SubPin->PinFriendlyName.ToString();
					SubPinFriendlyName.ReplaceInline(*OldFriendlyName, *ElementFriendlyName);

					SubPin->Modify();
					SubPin->PinName = *SubPin->PinName.ToString().Replace(*OldNameStr, *ElementNameStr);
					SubPin->PinFriendlyName = FText::FromString(SubPinFriendlyName);
				}
			}
		}
		else if (CurrentPin->Direction == EGPD_Output &&
			CurrentPin->ParentPin == nullptr)
		{
			CurrentNumOutputParentPins++;

			const FName OldName = CurrentPin->PinName;
			const FName ElementName = NewPinName(FPinNames::OutputValue, CurrentNumOutputParentPins);

			CurrentPin->Modify();
			CurrentPin->PinName = ElementName;

			if (CurrentPin->SubPins.Num() > 0)
			{
				const FString OldNameStr = OldName.ToString();
				const FString ElementNameStr = ElementName.ToString();
				FString OldFriendlyName = OldNameStr;
				FString ElementFriendlyName = ElementNameStr;

				// SubPin Friendly Name has an extra space in it so we need to account for that
				OldFriendlyName.InsertAt(1, " ");
				ElementFriendlyName.InsertAt(1, " ");

				for (UEdGraphPin* SubPin : CurrentPin->SubPins)
				{
					FString SubPinFriendlyName = SubPin->PinFriendlyName.ToString();
					SubPinFriendlyName.ReplaceInline(*OldFriendlyName, *ElementFriendlyName);

					SubPin->Modify();
					SubPin->PinName = *SubPin->PinName.ToString().Replace(*OldNameStr, *ElementNameStr);
					SubPin->PinFriendlyName = FText::FromString(SubPinFriendlyName);
				}
			}
		}
	}
}

FName UTouchMegaK2Node::GetPinName(const int32 PinIndex)
{
	//return *FString::Printf(TEXT("[%d]"), PinIndex);

	switch (PinIndex)
	{
	case 0:

		return "";
	case 1:
		return FPinNames::TouchEngineComponent;
		break;
	default:

		int InputNum = (PinIndex) / 2;

		if (InputNum <= NumInputs) // input var pin
		{
			// text pin
			if ((PinIndex % 2) == 0)
			{
				return NewPinName(FPinNames::InputName, InputNum);
			}
			// value pin
			else
			{
				return NewPinName(FPinNames::Value, InputNum);
			}
		}
		else // output var pin
		{
			return NewPinName(FPinNames::OutputName, PinIndex - 1 - (NumInputs * 2));
		}

		break;
	}
}

bool UTouchMegaK2Node::IsInputValuePin(UEdGraphPin* Pin)
{
	return Pin->PinName.ToString().StartsWith(FPinNames::Value.ToString());
}

bool UTouchMegaK2Node::IsInputNamePin(UEdGraphPin* Pin)
{
	return Pin->PinName.ToString().StartsWith(FPinNames::InputName.ToString());
}

bool UTouchMegaK2Node::IsOutputValuePin(UEdGraphPin* Pin)
{
	return Pin->PinName.ToString().StartsWith(FPinNames::OutputValue.ToString());
}

bool UTouchMegaK2Node::IsOutputNamePin(UEdGraphPin* Pin)
{
	return Pin->PinName.ToString().StartsWith(FPinNames::OutputName.ToString());
}

#undef LOCTEXT_NAMESPACE
